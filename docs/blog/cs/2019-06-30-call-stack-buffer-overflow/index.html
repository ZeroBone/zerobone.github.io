<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Call Stack - buffer overflow vulnerability | ZeroBone</title><meta name="generator" content="Jekyll v3.8.6" /><meta property="og:title" content="Call Stack - buffer overflow vulnerability" /><meta name="author" content="Alexander Mayorov" /><meta property="og:locale" content="en" /><meta name="description" content="Buffer overflows are a kind of call stack vulnerability that occur when buffers are created on the stack, but accessed improperly. Buffer underruns are typically not so dangerous, because writing in the current stack frame or beyond the stack pointer will only affect local variables on that stack frame. On the other side, buffer overruns can allow the attacker to overwrite the return address and thus even modify the program’s behaviour." /><meta property="og:description" content="Buffer overflows are a kind of call stack vulnerability that occur when buffers are created on the stack, but accessed improperly. Buffer underruns are typically not so dangerous, because writing in the current stack frame or beyond the stack pointer will only affect local variables on that stack frame. On the other side, buffer overruns can allow the attacker to overwrite the return address and thus even modify the program’s behaviour." /><link rel="canonical" href="https://zerobone.net/blog/cs/2019-06-30-call-stack-buffer-overflow/" /><meta property="og:url" content="https://zerobone.net/blog/cs/2019-06-30-call-stack-buffer-overflow/" /><meta property="og:site_name" content="ZeroBone" /><meta property="og:image" content="https://zerobone.net/assets/img/blog/call-stack-buffer-overflow.svg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-06-30T00:00:00+02:00" /> <script type="application/ld+json"> {"url":"https://zerobone.net/blog/cs/2019-06-30-call-stack-buffer-overflow/","headline":"Call Stack - buffer overflow vulnerability","dateModified":"2019-06-30T00:00:00+02:00","datePublished":"2019-06-30T00:00:00+02:00","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://zerobone.net/assets/icons/icon.png"},"name":"Alexander Mayorov"},"image":"https://zerobone.net/assets/img/blog/call-stack-buffer-overflow.svg","author":{"@type":"Person","name":"Alexander Mayorov"},"description":"Buffer overflows are a kind of call stack vulnerability that occur when buffers are created on the stack, but accessed improperly. Buffer underruns are typically not so dangerous, because writing in the current stack frame or beyond the stack pointer will only affect local variables on that stack frame. On the other side, buffer overruns can allow the attacker to overwrite the return address and thus even modify the program’s behaviour.","mainEntityOfPage":{"@type":"WebPage","@id":"https://zerobone.net/blog/cs/2019-06-30-call-stack-buffer-overflow/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><meta name="keywords" content="ZeroBone,Programming,Computer Science,Alexander,Mayorov,Math"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZeroBone"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="application-name" content="ZeroBone"><meta name="msapplication-config" content="/assets/ieconfig.xml"><meta name="theme-color" content="rgb(25,55,71)"><meta name="generator" content="ZeroBone" /><link type="application/atom+xml" rel="alternate" href="https://zerobone.net/feed.xml" title="ZeroBone" /><link rel="alternate" href="https://zerobone.net/blog/cs/2019-06-30-call-stack-buffer-overflow/" hreflang="en"><link rel="shortcut icon" href="/assets/icons/favicon.ico"><link rel="apple-touch-icon" href="/assets/icons/icon.png"><link rel="manifest" href="/assets/manifest.json"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="dns-prefetch" href="/" id="_baseURL"><link rel="dns-prefetch" href="/sw.js" id="_hrefSW"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js" id="_hrefKatexJS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css" id="_hrefKatexCSS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.js" id="_hrefKatexCopyJS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.css" id="_hrefKatexCopyCSS"><link rel="dns-prefetch" href="/assets/img/swipe.svg" id="_hrefSwipeSVG"> <script> !function(e,t){"use strict";function n(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,o){var r=t.createElement("script");r.src=e,o&&n(r,"load",o,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(r,a),r},e._loaded=!1,e.loadJSDeferred=function(o,r){function a(){e._loaded=!0,r&&n(c,"load",r,{once:!0});var o=t.scripts[0];o.parentNode.insertBefore(c,o)}var c=t.createElement("script");return c.src=o,e._loaded?a():n(e,"load",a,{once:!0}),c},e.setRel=e.setRelStylesheet=function(e){function o(){this.rel="stylesheet"}n(t.getElementById(e),"load",o,{once:!0})}}(window,document); ; !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); ; !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); ; !function(w, d) { w._noPushState = false; w._noDrawer = false; }(window, document); </script> <!--[if gt IE 8]><!----><style> body{--code-font-family: Menlo,Monaco,Consolas,monospace;--font-weight: 400;--font-weight-bold: 700;--font-weight-heading: 400;--text-muted: #888;--gray-bg: rgba(0,0,0,0.025);--gray-text: #666;--menu-text: #bbb;--body-color: #333;--body-bg: #fff;--border-color: #ebebeb}.clearfix,.sidebar-social::after{content:"";display:table;clear:both}.color-transition,body,p,hr,.hr,table:not(.highlight) td,table:not(.highlight) th,.message{transition:background-color 1s ease, border-color 1s ease}.no-color-transition{transition:none !important}@media screen{body.light-mode{--text-muted: #888;--gray-bg: rgba(0,0,0,0.025);--gray-text: #666;--menu-text: #bbb;--body-color: #333;--body-bg: #fff;--border-color: #ebebeb}body.dark-mode{--text-muted: rgba(255,255,255,.5);--gray-bg: rgba(255,255,255,.033);--gray-text: rgba(255,255,255,.625);--menu-text: rgba(255,255,255,.25);--body-color: #ccc;--body-bg: #2d3539;--border-color: #3d494f}}*{box-sizing:border-box}html,body{margin:0;padding:0}html{font-size:16px;line-height:1.75}body{color:var(--body-color);background-color:var(--body-bg);font-weight:var(--font-weight);overflow-y:scroll}a{text-decoration:none}.lead{margin-left:-1rem;margin-right:-1rem}.content img,.img,.content video,.video{max-width:100%}.content img.lead,.img.lead,.content video.lead,.video.lead{max-width:calc(100% + 2rem);width:calc(100% + 2rem)}h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6{font-weight:var(--font-weight-heading);margin:5rem 0 1rem}h1,.h1{font-size:2rem;line-height:1.3}h2,.h2{font-size:1.5rem;line-height:1.4}h3,.h3{font-size:1.17em;line-height:1.5}h4,h5,h6,.h4,.h5,.h6{font-size:1rem;margin-bottom:0.5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.2em;margin-top:1.5rem;margin-bottom:1.5rem;padding:0 1rem}ul,ol,dl{margin-top:0;margin-bottom:1rem}ul,ol{padding-left:1.25rem}hr{position:relative;margin:3rem 0;border:0;border-top:1px solid var(--border-color)}.hr{border-bottom:1px solid var(--border-color);padding-bottom:1rem;margin-bottom:2rem}table:not(.highlight){border-collapse:collapse;margin-bottom:2rem;margin-left:-1rem}table:not(.highlight) td,table:not(.highlight) th{padding:.25rem .5rem;border:1px solid var(--border-color)}table:not(.highlight) td:first-child,table:not(.highlight) th:first-child{padding-left:1rem}table:not(.highlight) td:last-child,table:not(.highlight) th:last-child{padding-right:1rem}.page{margin-bottom:3em}.page li+li{margin-top:.25rem}.page>header{margin-bottom:2rem}.page-title,.post-title{margin-top:0}.post-date{display:block;margin-top:-0.5rem;margin-bottom:1rem;color:var(--text-muted)}.related-posts{padding-left:0;list-style:none;margin-bottom:2rem}.related-posts>li,.related-posts>li+li{margin-top:1rem}.message{margin-bottom:1rem;padding:1rem;color:var(--gray-text);background-color:var(--gray-bg);margin-left:-1rem;margin-right:-1rem}@media screen{body::before{content:'';width:.5rem;background:var(--border-color);position:fixed;left:0;top:0;bottom:0}}@media screen and (min-width: 64em){body::before{width:21rem}}@media screen and (min-width: 1666px){body::before{width:calc(50% - 28rem)}}@media screen and (min-width: 42em){html{font-size:17px}}@media screen and (min-width: 124em){html{font-size:18px}}.fade-in{animation-duration:500ms;animation-timing-function:ease;animation-name:fade-in;animation-fill-mode:forwards}@keyframes fade-in{from{transform:translateY(-3rem);opacity:0}50%{transform:translateY(-3rem);opacity:0}to{transform:translateY(0);opacity:1}}.fl{float:left}.fr{float:right}.mb4{margin-bottom:4rem}.mb6{margin-bottom:6rem}.mt0{margin-top:0}.mt2{margin-top:2rem}.mt3{margin-top:3rem}.mt4{margin-top:4rem}.pb0{padding-bottom:0}.sixteen-nine{position:relative}.sixteen-nine::before{display:block;content:"";width:100%;padding-top:56.25%}.sixteen-nine>*{position:absolute;top:0;left:0;right:0;bottom:0}.sr-only{display:none}.border{border:1px solid var(--border-color)}hy-push-state a,.a{position:relative;padding-bottom:.15rem;border-bottom:1px solid}hy-push-state a.no-hover,.a.no-hover{border-bottom:none;padding-bottom:0}.content .img{overflow:hidden}.content .img img{margin:0;width:100%;height:100%;background-color:var(--gray-bg)}hy-drawer{width:100%;position:relative;overflow:hidden}@media screen and (min-width: 64em){hy-drawer{position:fixed;width:21rem;top:0;left:0;bottom:0;margin-left:0}hy-drawer.cover{position:relative;width:100%}}@media screen and (min-width: 1666px){hy-drawer{width:calc(50% - 28rem)}}.sidebar{position:relative;display:flex;justify-content:center;align-items:center;color:rgba(255,255,255,0.75);text-align:center;z-index:2;min-height:100vh}.sidebar a{color:#fff;border-bottom-color:rgba(255,255,255,0.2)}.sidebar-bg{position:absolute;top:0;left:calc(50% - 50vw);width:100vw;height:100%;background:#202020 center / cover}.sidebar-bg::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(0,0,0,0.05)}.sidebar-bg.sidebar-overlay::after{background:linear-gradient(to bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 50%, rgba(32,32,32,0) 100%)}.sidebar-sticky{position:relative;z-index:3;max-width:21rem;padding:1.5rem;contain:content}.sidebar-about .avatar{margin-bottom:1.5rem}.sidebar-about>h2{margin-top:0}.sidebar-nav>ul{list-style:none;padding-left:0}a.sidebar-nav-item{display:inline-block;font-weight:var(--font-weight-heading);line-height:1.75;padding:.25rem;border-bottom:1px solid rgba(255,255,255,0.2)}.sidebar-social>ul{display:inline-block;list-style:none;padding-left:0;margin-bottom:0}.sidebar-social>ul>li{float:left}.sidebar-social>ul>li>a{display:inline-block;text-align:center;font-size:1.4rem;width:3rem;height:4rem;padding:.5rem 0;line-height:3rem}.sidebar-social>ul li+li{margin-top:0}.fixed-common,.fixed-top,.fixed-bottom{position:fixed;left:0;width:100%;z-index:2}.fixed-top{top:0}.fixed-bottom{bottom:0}.navbar>.content{padding-top:0;padding-bottom:0;min-height:0;color:var(--menu-text)}.nav-btn-bar{margin:0 -1rem 0 -.875rem}.nav-btn{background:none;border:none;padding:1.75rem .875rem;color:var(--menu-text) !important;cursor:pointer}.animation-main{opacity:0;pointer-events:none}.content{position:relative;margin-left:auto;margin-right:auto;padding:6rem 1rem 12rem}@media screen{.content{padding-left:1.5rem;max-width:38rem;min-height:100vh}}@media screen and (min-width: 54em){.content{max-width:42rem}}@media screen and (min-width: 64em){.content{padding-left:1rem;margin-left:24rem;margin-right:3rem}}@media screen and (min-width: 88em){.content{margin-left:25rem;margin-right:4rem;max-width:48rem}}@media screen and (min-width: 1666px){.content{margin:auto}}.avatar{width:6.5rem;height:6.5rem;border-radius:100%;overflow:hidden}@media screen and (min-width: 88em){.avatar{width:7rem;height:7rem}}.content .avatar{float:right;margin-left:.5rem}html{font-family:Noto Sans,Helvetica,Arial,sans-serif}h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6,.heading{font-family:Roboto Slab,Helvetica,Arial,sans-serif}</style><link rel="preload" as="style" href="/assets/css/zerobone.css" id="_stylePreload"><link rel="preload" as="style" href="/assets/icomoon/style.css" id="_iconsPreload"><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Roboto+Slab:400|Noto+Sans:400,400i,700,700i&display=swap" id="_fontsPreload"> <script>setRel('_stylePreload');setRel('_iconsPreload');/**/setRel('_fontsPreload');/**/</script> <noscript><link rel="stylesheet" href="/assets/css/zerobone.css"><link rel="stylesheet" href="/assets/icomoon/style.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:400|Noto+Sans:400,400i,700,700i&display=swap"> </noscript><style id="_pageStyle"> .content a:not(.btn){color:#268bd2;border-color:rgba(38,139,210,0.2)}.content a:not(.btn):hover{border-color:#268bd2}:focus{outline-color:#268bd2 !important}.btn-primary{color:#fff;background-color:#268bd2;border-color:#268bd2}.btn-primary:focus,.btn-primary.focus,.form-control:focus,.form-control.focus{box-shadow:0 0 0 3px rgba(38,139,210,0.5)}.btn-primary:hover,.btn-primary.hover{color:#fff;background-color:#2076b2;border-color:#2076b2}.btn-primary:disabled,.btn-primary.disabled{color:#fff;background-color:#268bd2;border-color:#268bd2}.btn-primary:active,.btn-primary.active{color:#fff;background-color:#2076b2;border-color:#2076b2}::selection{color:#fff;background:#268bd2}::-moz-selection{color:#fff;background:#268bd2}</style><!--<![endif]--><body class="no-color-transition dark-mode"><div id="_navbar" class="navbar fixed-top"><div class="content"><div class="nav-btn-bar"> <span class="sr-only">Jump to:</span> <a id="_menu" class="nav-btn no-hover fl" href="#_navigation"> <span class="sr-only">Navigation</span> <span class="icon-menu"></span> </a></div></div></div><hr class="sr-only" hidden /> <hy-push-state replace-ids="_main" link-selector="a[href]:not([href*='/assets/']):not(.external):not(.no-push-state)" duration="250" script-selector="script:not([type^='math/tex'])" prefetch ><main id="_main" class="content fade-in layout-post" role="main" data-color="rgb(38,139,210)" data-theme-color="rgb(25,55,71)" data-background="rgb(32,32,32)" ><article id="post-blog-cs-call-stack-buffer-overflow" class="page post mb6" role="article"><header><h1 class="post-title"> Call Stack - buffer overflow vulnerability</h1><p class="post-date heading"> <time datetime="2019-06-30T00:00:00+02:00">30 Jun 2019</time> in <a href="/blog/cs/" class="flip-title">Computer Science</a><div class="img lead sixteen-nine"> <hy-img src="/assets/img/blog/call-stack-buffer-overflow.svg" alt="Call Stack - buffer overflow vulnerability" root-margin="512px" > <noscript><img data-ignore src="/assets/img/blog/call-stack-buffer-overflow.svg" alt="Call Stack - buffer overflow vulnerability" /></noscript> <span class="loading" slot="loading" hidden> <span class="icon-cog"></span> </span> </hy-img></div></header><p>Buffer overflows are a kind of call stack vulnerability that occur when buffers are created on the stack, but accessed improperly. Buffer underruns are typically not so dangerous, because writing in the current stack frame or beyond the stack pointer will only affect local variables on that stack frame. On the other side, buffer overruns can allow the attacker to overwrite the return address and thus even modify the program’s behaviour.<h2 id="buffer-overflow">Buffer overflow</h2><p>C programmers often allocate buffers on the stack to handle user input. If the input reading logic is implemented incorrectly and has now buffer length checks, a underflow/overflow can happen. If the user input is long enouph, it will overwrite the saved <code class="highlighter-rouge">ebp</code> register of the previous stack frame and, what matters most, the return address.<p><hy-img root-margin="512px" src="/assets/img/blog/call-stack-buffer-overflow.svg" alt="Stack buffer overflow">  <noscript><img data-ignore src="/assets/img/blog/call-stack-buffer-overflow.svg" alt="Stack buffer overflow"/></noscript>  <span slot="loading" class="loading"><span class="icon-cog"></span></span></hy-img><h2 id="example">Example</h2><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	
	<span class="kt">int</span><span class="o">*</span> <span class="n">prevEbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">"Buffer start: %p Buffer start pointer address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Previous EBP: %p Value: %d Value as hex: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prevEbp</span><span class="p">,</span> <span class="o">*</span><span class="n">prevEbp</span><span class="p">,</span> <span class="o">*</span><span class="n">prevEbp</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Return address: %p Value: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Buffer end: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	
	<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
	
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Ptr size: %d bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
	<span class="n">fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>We can calculate the return address position by taking addresses of the buffer and the function arguments. In this case we only take the pointer to the first argument, because it is added to the stack last. The previous base pointer size as well as the return address size are 4 bytes, so we can just subtract 1 (<code class="highlighter-rouge">4</code> bytes) from the pointer to get the return address and 2 (<code class="highlighter-rouge">8</code> bytes) to get the base pointer.<p>We can now compile the program with the <code class="highlighter-rouge">-fno-stack-protector</code> flag to disable stack protecting canary that <code class="highlighter-rouge">gcc</code> adds by default:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc main.c <span class="nt">-o</span> viewret <span class="nt">-fno-stack-protector</span>
</code></pre></div></div><p>By running the program I got:<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ptr size: 4 bytes
Buffer start: 0061FEE8 Buffer start pointer address: 0061FEE8
Previous EBP: 0061FF08 Value: 6422312 Value as hex: 61ff28
Return address: 0061FF0C Value: 401508
Buffer end: 0061FEF8
</code></pre></div></div><p>We can easly alter the return address value now:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	
	<span class="kt">int</span><span class="o">*</span> <span class="n">prevEbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">"Buffer start: %p Buffer start pointer address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Previous EBP: %p Value: %d Value as hex: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prevEbp</span><span class="p">,</span> <span class="o">*</span><span class="n">prevEbp</span><span class="p">,</span> <span class="o">*</span><span class="n">prevEbp</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Return address: %p Value: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Buffer end: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	
	<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
	
	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="mh">0xcafeefac</span><span class="p">;</span>
	
<span class="p">}</span>
</code></pre></div></div><p>Now, if we run the program we will get a <code class="highlighter-rouge">segmentation fault</code> error because the function will try to jump back to the calee using an invalid address.<p>We can examine exactly how it works by running the <code class="highlighter-rouge">GDB</code> debugger:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gdb viewret.exe
</code></pre></div></div><p>Of course, we need to set the breakpoint at the <code class="highlighter-rouge">fun</code> function:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>br fun
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[New Thread 3388.0x3368]
[New Thread 3388.0x1a2c]
Ptr size: 4 bytes

Breakpoint 1, 0x00401416 in fun ()
</code></pre></div></div><p>By using the <code class="highlighter-rouge">frame</code> command we can view the saved registers if the current stack frame.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>info frame
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stack level 0, frame at 0x61ff10:
 eip = 0x401416 in fun; saved eip 0x401508
 called by frame at 0x61ff30
 Arglist at 0x61ff08, args:
 Locals at 0x61ff08, Previous frame's sp is 0x61ff10
 Saved registers:
  ebp at 0x61ff08, eip at 0x61ff0c
</code></pre></div></div><p>The <code class="highlighter-rouge">ebp</code> register of the previous stack frame is at address <code class="highlighter-rouge">0x61ff08</code>, the return address - at <code class="highlighter-rouge">0x61ff0c</code>. The values are the same as generated by the program above.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>c
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Continuing.
Buffer start: 0061FEE8 Buffer start pointer address: 0061FEE8
Previous EBP: 0061FF08 Value: 6422312 Value as hex: 61ff28
Return address: 0061FF0C Value: 401508
Buffer end: 0061FEF8

Program received signal SIGSEGV, Segmentation fault.
0xcafeefac in ?? ()
</code></pre></div></div><p>By stepping over the breakpoint we can see the invalid return address that caused the segmentation fault.<h2 id="altering-variables">Altering variables</h2><p>Let’s examine another program that reads data from the standart input stream:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">zero</span><span class="p">;</span>
	
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	
	<span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"You changed the zero variable to %d (hex: %x)!"</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">"Variable not changed."</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>The <code class="highlighter-rouge">zero</code> variable is marked as <code class="highlighter-rouge">volatile</code> to prevent the compiler from optimizing it’s usage, e.g. by caching it’s value in one of the general-purpose registers.<p>By dissassembling with <code class="highlighter-rouge">GDB</code> we get:<pre><code class="language-assembly">0x00401410 &lt;+0&gt;:     push   ebp ; save the previous ebp register
0x00401411 &lt;+1&gt;:     mov    ebp,esp ; initializing ebp of the new stack frame
0x00401413 &lt;+3&gt;:     and    esp,0xfffffff0 ; memory aligning
0x00401416 &lt;+6&gt;:     sub    esp,0x60 ; memory allocation on the stack
0x00401419 &lt;+9&gt;:     call   0x401980 &lt;__main&gt;
0x0040141e &lt;+14&gt;:    mov    DWORD PTR [esp+0x5c],0x0 ; assign to zero
; eax = esp + 0x1c
0x00401426 &lt;+22&gt;:    lea    eax,[esp+0x1c]
; the address calculated with the previous instruction gets saved on the stack
0x0040142a &lt;+26&gt;:    mov    DWORD PTR [esp],eax
0x0040142d &lt;+29&gt;:    call   0x403ae8 &lt;gets&gt; ; gets() call
; load the value from the memory for comparison
0x00401432 &lt;+34&gt;:    mov    eax,DWORD PTR [esp+0x5c]
0x00401436 &lt;+38&gt;:    test   eax,eax ; test if it is zero
0x00401438 &lt;+40&gt;:    je     0x401458 &lt;main+72&gt; 
0x0040143a &lt;+42&gt;:    mov    edx,DWORD PTR [esp+0x5c]
; commands needed for printf
0x0040143e &lt;+46&gt;:    mov    eax,DWORD PTR [esp+0x5c]
0x00401442 &lt;+50&gt;:    mov    DWORD PTR [esp+0x8],edx
0x00401446 &lt;+54&gt;:    mov    DWORD PTR [esp+0x4],eax
0x0040144a &lt;+58&gt;:    mov    DWORD PTR [esp],0x405044
0x00401451 &lt;+65&gt;:    call   0x403ac8 &lt;printf&gt; ; success print
0x00401456 &lt;+70&gt;:    jmp    0x401464 &lt;main+84&gt; ; jump over the else branch
0x00401458 &lt;+72&gt;:    mov    DWORD PTR [esp],0x405073
0x0040145f &lt;+79&gt;:    call   0x403ac0 &lt;puts&gt; ; error print
; return with exit code 0
0x00401464 &lt;+84&gt;:    mov    eax,0x0
0x00401469 &lt;+89&gt;:    leave
0x0040146a &lt;+90&gt;:    ret
0x0040146b &lt;+91&gt;:    nop
0x0040146c &lt;+92&gt;:    xchg   ax,ax
0x0040146e &lt;+94&gt;:    xchg   ax,ax
</code></pre><p>We can set 2 breakpoints - before and after the <code class="highlighter-rouge">gets()</code> call.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>br <span class="k">*</span>0x0040142d
<span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>br <span class="k">*</span>0x00401432
</code></pre></div></div><p>With gdb we can define what commands to run when these breakpoints are reached:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>define hook-stop
<span class="o">&gt;</span>info registers
<span class="o">&gt;</span>x/24wx <span class="nv">$esp</span>
<span class="o">&gt;</span>x/2i <span class="nv">$eip</span>
<span class="o">&gt;</span>end
</code></pre></div></div><p>With the commands above we will see the register state, 24 machine words on the stack and two next instuctions after the instruction pointer:<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eax            0x61fedc 6422236
ecx            0x4018f0 4200688
edx            0x50000018       1342177304
ebx            0x2d2000 2957312
esp            0x61fec0 0x61fec0
ebp            0x61ff28 0x61ff28
esi            0x4012d0 4199120
edi            0x4012d0 4199120
eip            0x40142d 0x40142d &lt;main+29&gt;
eflags         0x202    [ IF ]
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x53     83
gs             0x2b     43
0x61fec0:       0x0061fedc      0x00000008      0x772c8023      0x772c801a
0x61fed0:       0xb3b6879d      0x004012d0      0x004012d0      0x00000000
0x61fee0:       0x004018f0      0x0061fed0      0x0061ff08      0x0061ffcc
0x61fef0:       0x772cdd70      0xc4e6dd59      0xfffffffe      0x772c801a
0x61ff00:       0x772c810d      0x004018f0      0x0061ff50      0x0040195b
0x61ff10:       0x004018f0      0x00000000      0x002d2000      0x00000000
=&gt; 0x40142d &lt;main+29&gt;:  call   0x403ae8 &lt;gets&gt;
   0x401432 &lt;main+34&gt;:  mov    eax,DWORD PTR [esp+0x5c]

Breakpoint 1, 0x0040142d in main ()
</code></pre></div></div><p>Now we can examine how the input affects the stack:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>c
Continuing.
0000000000000000000000000000000000000000000
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eax            0x61fedc 6422236
ecx            0x772eb098       1999548568
edx            0xa      10
ebx            0x2d2000 2957312
esp            0x61fec0 0x61fec0
ebp            0x61ff28 0x61ff28
esi            0x4012d0 4199120
edi            0x4012d0 4199120
eip            0x401432 0x401432 &lt;main+34&gt;
eflags         0x216    [ PF AF IF ]
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x53     83
gs             0x2b     43
0x61fec0:       0x0061fedc      0x00000008      0x772c8023      0x772c801a
0x61fed0:       0xb3b6879d      0x004012d0      0x004012d0      0x30303030
0x61fee0:       0x30303030      0x30303030      0x30303030      0x30303030
0x61fef0:       0x30303030      0x30303030      0x30303030      0x30303030
0x61ff00:       0x30303030      0x00303030      0x0061ff50      0x0040195b
0x61ff10:       0x004018f0      0x00000000      0x002d2000      0x00000000
=&gt; 0x401432 &lt;main+34&gt;:  mov    eax,DWORD PTR [esp+0x5c]
   0x401436 &lt;main+38&gt;:  test   eax,eax

Breakpoint 2, 0x00401432 in main ()
</code></pre></div></div><p>As we see, 43 zero-characters (ascii code <code class="highlighter-rouge">0x30</code>) was not enouph to get to the zero value that we want ti akter. In order to get to the value, we need 64 bytes (because the buffer size is 64). For demonstration purpuses we will use the following string as the input:<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000011111111111111112222222222222222333333333333333344444444444456
</code></pre></div></div><p>This string contains 66 characters, so the 2 last characters <code class="highlighter-rouge">5</code> and <code class="highlighter-rouge">6</code> should overwrite the 2 least significant bytes (because memory endianness is <code class="highlighter-rouge">little-endian</code>) of the variable.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>c
Continuing.
000011111111111111112222222222222222333333333333333344444444444456
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eax            0x61fedc 6422236
ecx            0x772eb098       1999548568
edx            0xa      10
ebx            0x3f9000 4165632
esp            0x61fec0 0x61fec0
ebp            0x61ff28 0x61ff28
esi            0x4012d0 4199120
edi            0x4012d0 4199120
eip            0x401432 0x401432 &lt;main+34&gt;
eflags         0x216    [ PF AF IF ]
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x53     83
gs             0x2b     43
0x61fec0:       0x0061fedc      0x00000008      0x772c8023      0x772c801a
0x61fed0:       0xe53b01b1      0x004012d0      0x004012d0      0x30303030
0x61fee0:       0x31313131      0x31313131      0x31313131      0x31313131
0x61fef0:       0x32323232      0x32323232      0x32323232      0x32323232
0x61ff00:       0x33333333      0x33333333      0x33333333      0x33333333
0x61ff10:       0x34343434      0x34343434      0x34343434      0x00003635
=&gt; 0x401432 &lt;main+34&gt;:  mov    eax,DWORD PTR [esp+0x5c]
   0x401436 &lt;main+38&gt;:  test   eax,eax

Breakpoint 2, 0x00401432 in main ()
</code></pre></div></div><p>By continuing we see that the variable now contains <code class="highlighter-rouge">0x3635</code> or <code class="highlighter-rouge">13877</code> in decimal.<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nv">$ </span>c
</code></pre></div></div><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Continuing.
You changed the zero variable to 13877 (hex: 3635)![Inferior 1 (process 4848) exited normally]
Error while running hook_stop:
The program has no registers now.
</code></pre></div></div><p>In order to alter the <code class="highlighter-rouge">zero</code> variable we need to represent the number in the <code class="highlighter-rouge">little endian</code> form and write the corresponding bytes to the 65, 66, 67 and 68 offsets in in buffer.<h2 id="protection-against-buffer-overflows">Protection against buffer overflows</h2><p>Compilers and operating systems have some techniques to prevent such stack exploits. In <code class="highlighter-rouge">gcc</code>, for example, if the function allocates a buffer on the stack, an additional socalled <code class="highlighter-rouge">stack canary</code> is added. A stack canary is just a random integer generated when the function is called. Before returning the function makes sure that the canary has the same value. If the canary has been altered, the program is terminated with a fatal <code class="highlighter-rouge">Stack smashing detected</code> error.<p>Another technique used by operating systems is restricting code evaluation on the stack. When the stack overflow is exploited, hackers will try to overwrite the return address so that it points at the buffer location with the malicious code injected. Even if the exact address is not known, it is possible to construct a <code class="highlighter-rouge">NO-OP</code>-instruction slide in the stack buffer so that jump at any address within this slide will lead to malicious code execution. Exact stack addresses are typically different after every program run because operating systems push environmental variables onto it.</article><hr class="dingbat related" /><aside class="about related mt4 mb4" role="complementary"><div class="author mt4"> <hy-img src="/assets/icons/logo_128.png" class="avatar" alt="Alexander Mayorov" srcset="/assets/icons/logo_128.png 1x,/assets/icons/logo_256.png 2x" root-margin="512px" > <noscript><img data-ignore src="/assets/icons/logo_128.png" class="avatar" alt="Alexander Mayorov" srcset="/assets/icons/logo_128.png 1x,/assets/icons/logo_256.png 2x" /></noscript> <span class="loading" slot="loading" hidden> <span class="icon-cog"></span> </span> </hy-img><h2 class="page-title hr"> About</h2><p>Computer Science student &amp; backend developer.<div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://github.com/ZeroBone" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a><li> <a href="mailto:zerobone21@gmail.com" title="Email" class="no-mark-external"> <span class="icon-mail"></span> <span class="sr-only">Email</span> </a><li> <a href="https://vk.com/alxmay" title="VK" class="no-mark-external"> <span class="icon-vk"></span> <span class="sr-only">VK</span> </a></ul></div></div></aside><aside class="related mb4" role="complementary"><h2 class="hr">Related Posts</h2><ul class="related-posts"><li> <a href="/blog/cs/2020-08-29-numbers-are-regular-languages/" class="h4 flip-title"><span>Numbers in congruence classes are regular languages</span></a> <time class="heading faded fine" datetime="2020-08-29T00:00:00+02:00">29 Aug 2020</time><li> <a href="/blog/cs/2020-02-21-non-recursive-extended-euklidian-algorithm/" class="h4 flip-title"><span>Extended Euclidean algorithm without stack or recursion</span></a> <time class="heading faded fine" datetime="2020-02-21T00:00:00+01:00">21 Feb 2020</time></ul></aside><aside class="related mb4" role="complementary"><h2 class="hr">Random Posts</h2><ul class="related-posts"><li> <a href="/blog/cs/2020-08-29-numbers-are-regular-languages/" class="h4 flip-title"><span>Numbers in congruence classes are regular languages</span></a> <time class="heading faded fine" datetime="2020-08-29T00:00:00+02:00">29 Aug 2020</time><li> <a href="/blog/cs/2020-02-21-non-recursive-extended-euklidian-algorithm/" class="h4 flip-title"><span>Extended Euclidean algorithm without stack or recursion</span></a> <time class="heading faded fine" datetime="2020-02-21T00:00:00+01:00">21 Feb 2020</time></ul></aside><footer role="contentinfo"><hr/><p><small class="copyright">Copyright © 2020 Alexander Mayorov. All rights reserved. </small><hr class="sr-only"/></footer></main><hy-drawer class="" align="left" threshold="10" touch-events prevent-default ><header id="_sidebar" class="sidebar" role="banner"><div class="sidebar-bg " style="background:rgb(32,32,32)"></div><div class="sidebar-sticky"><div class="sidebar-about"> <a class="no-hover" href="/" tabindex="-1"> <img src="/assets/icons/icon.png" class="avatar" alt="ZeroBone" data-ignore /> </a><h2 class="h1"><a href="/">ZeroBone</a></h2><p class=""> Computer Science student &amp; backend developer.</div><nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span><ul><li> <a id="_navigation" href="/blog/" class="sidebar-nav-item active" > Blog </a><li> <a href="/projects/" class="sidebar-nav-item" > Projects </a><li> <a href="/resume/" class="sidebar-nav-item" > Resume </a></ul></nav><div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://github.com/ZeroBone" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a><li> <a href="mailto:zerobone21@gmail.com" title="Email" class="no-mark-external"> <span class="icon-mail"></span> <span class="sr-only">Email</span> </a><li> <a href="https://vk.com/alxmay" title="VK" class="no-mark-external"> <span class="icon-vk"></span> <span class="sr-only">VK</span> </a></ul></div></div></header></hy-drawer><hr class="sr-only" hidden /> </hy-push-state> <!--[if gt IE 10]><!----> <script nomodule>!function(){var e=document.createElement("script");if(!("noModule"in e)&&"onbeforeload"in e){var t=!1;document.addEventListener("beforeload",function(n){if(n.target===e)t=!0;else if(!n.target.hasAttribute("nomodule")||!t)return;n.preventDefault()},!0),e.type="module",e.src=".",document.head.appendChild(e),e.remove()}}(); </script> <script type="module" src="/assets/js/zerobone-v.js"></script> <script nomodule src="/assets/js/zerobone-legacy-v.js" defer></script> <script type="module"> if ('serviceWorker' in navigator) { /**/ navigator.serviceWorker.getRegistration() .then(r => r.unregister()) .catch(() => {}); /**/ } </script> <!--<![endif]--><h2 class="sr-only" hidden>Templates (for web app):</h2><template id="_animation-template" hidden><div class="animation-main fixed-top"><div class="content"><div class="page"></div></div></div></template> <template id="_loading-template" hidden><div class="loading nav-btn fr"> <span class="sr-only">Loading…</span> <span class="icon-cog"></span></div></template> <template id="_error-template" hidden><div class="page"><h1 class="page-title">Error</h1><p class="lead"> An error occurred while loading <a class="this-link" href=""></a>.</div></template> <template id="_forward-template" hidden> <button id="_forward" class="forward nav-btn no-hover fl"> <span class="sr-only">Forward</span> <span class="icon-arrow-right2"></span> </button> </template> <template id="_back-template" hidden> <button id="_back" class="back nav-btn no-hover fl"> <span class="sr-only">Back</span> <span class="icon-arrow-left2"></span> </button> </template> <template id="_permalink-template" hidden> <a href="#" class="permalink"> <span class="sr-only">Permalink</span> <span class="icon-link"></span> </a> </template> <template id="_dark-mode-template" hidden> <button id="_dark-mode" class="nav-btn no-hover fl" > <span class="sr-only">Dark Mode</span> <span class="icon-contrast"></span> </button> </template></html>
